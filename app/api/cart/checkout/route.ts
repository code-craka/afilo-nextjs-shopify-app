import { NextRequest, NextResponse } from 'next/server';
import { serverGetCart } from '@/lib/shopify-server';
import { getSecretCartId } from '@/app/api/cart/server-create/route';

// CRITICAL SECURITY: Checkout URL generation follows Shopify best practice
// Official Shopify Guidance: "checkoutUrl should be requested when buyer is ready to navigate"

interface CheckoutRequest {
  sessionId: string; // Safe client identifier
  buyerIdentity?: {
    email?: string;
    phone?: string;
    countryCode?: string;
    customerAccessToken?: string; // For authenticated checkout
  };
}

interface CheckoutResponse {
  success: boolean;
  checkoutUrl?: string;
  cart?: {
    totalQuantity: number;
    cost: {
      totalAmount: {
        amount: string;
        currencyCode: string;
      };
      subtotalAmount: {
        amount: string;
        currencyCode: string;
      };
      totalTaxAmount?: {
        amount: string;
        currencyCode: string;
      };
    };
  };
  error?: string;
}

// Rate limiting for checkout requests
const rateLimitMap = new Map<string, { count: number; resetTime: number }>();

function checkRateLimit(request: NextRequest): boolean {
  const forwarded = request.headers.get('x-forwarded-for');
  const ip = forwarded ? forwarded.split(',')[0] : 'unknown';
  const key = `cart-checkout:${ip}`;

  const now = Date.now();
  const windowMs = 15 * 60 * 1000; // 15 minutes
  const maxRequests = 5; // Very conservative for checkout requests

  const record = rateLimitMap.get(key);

  if (!record || now > record.resetTime) {
    rateLimitMap.set(key, { count: 1, resetTime: now + windowMs });
    return true;
  }

  if (record.count >= maxRequests) {
    return false;
  }

  record.count++;
  return true;
}

export async function POST(request: NextRequest): Promise<NextResponse<CheckoutResponse>> {
  try {
    // Rate limiting
    if (!checkRateLimit(request)) {
      return NextResponse.json(
        {
          success: false,
          error: 'Rate limit exceeded. Please try again later.'
        },
        { status: 429 }
      );
    }

    const body: CheckoutRequest = await request.json();

    // Validate request
    if (!body.sessionId) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request: sessionId is required'
        },
        { status: 400 }
      );
    }

    // CRITICAL SECURITY: Retrieve secret cart ID server-side ONLY
    const secretCartId = getSecretCartId(body.sessionId);

    if (!secretCartId) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid cart session. Please refresh your cart.'
        },
        { status: 404 }
      );
    }

    // Retrieve current cart state from Shopify
    const cartResult = await serverGetCart(secretCartId);

    if (!cartResult.cart) {
      return NextResponse.json(
        {
          success: false,
          error: 'Cart not found. Please refresh your cart.'
        },
        { status: 404 }
      );
    }

    const cart = cartResult.cart;

    // Validate cart has items
    if (!cart.lines?.edges?.length) {
      return NextResponse.json(
        {
          success: false,
          error: 'Cart is empty. Please add items before checkout.'
        },
        { status: 400 }
      );
    }

    // Validate cart total (enterprise security check)
    const totalAmount = parseFloat(cart.cost.totalAmount.amount);
    if (totalAmount <= 0) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid cart total. Please refresh your cart.'
        },
        { status: 400 }
      );
    }

    // Enterprise validation: Minimum order value for B2B sales
    if (totalAmount < 99) {
      return NextResponse.json(
        {
          success: false,
          error: 'Minimum order value for enterprise software is $99. Please add more items.'
        },
        { status: 400 }
      );
    }

    // Optional: Update buyer identity if provided (for authenticated checkout)
    if (body.buyerIdentity) {
      // This would require additional mutation to update cart buyer identity
      // For now, we'll use the existing cart checkout URL
      console.log('Buyer identity provided for checkout:', body.buyerIdentity);
    }

    // SECURITY: checkoutUrl is generated by Shopify and is safe to return
    // It contains no sensitive cart secret information
    const checkoutUrl = cart.checkoutUrl;

    if (!checkoutUrl) {
      return NextResponse.json(
        {
          success: false,
          error: 'Checkout URL not available. Please try again.'
        },
        { status: 500 }
      );
    }

    // Log checkout attempt for monitoring
    console.log(`ðŸ›’ Checkout initiated:`, {
      sessionId: body.sessionId,
      totalAmount: cart.cost.totalAmount.amount,
      currency: cart.cost.totalAmount.currencyCode,
      itemCount: cart.lines.edges.length,
      hasCustomer: !!body.buyerIdentity?.customerAccessToken
    });

    // Return safe checkout data
    const response: CheckoutResponse = {
      success: true,
      checkoutUrl,
      cart: {
        totalQuantity: cart.totalQuantity || 0,
        cost: {
          totalAmount: cart.cost.totalAmount,
          subtotalAmount: cart.cost.subtotalAmount,
          ...(cart.cost.totalTaxAmount && { totalTaxAmount: cart.cost.totalTaxAmount })
        }
      }
    };

    return NextResponse.json(response, { status: 200 });

  } catch (error) {
    console.error('Checkout URL generation error:', error);

    let errorMessage = 'Failed to generate checkout URL';
    let statusCode = 500;

    if (error instanceof Error) {
      errorMessage = error.message;

      if (errorMessage.includes('authentication') || errorMessage.includes('unauthorized')) {
        statusCode = 401;
      } else if (errorMessage.includes('rate limit')) {
        statusCode = 429;
      } else if (errorMessage.includes('not found')) {
        statusCode = 404;
        errorMessage = 'Cart not found. Please refresh your cart.';
      }
    }

    return NextResponse.json(
      {
        success: false,
        error: errorMessage
      },
      { status: statusCode }
    );
  }
}

// Optional: GET endpoint to retrieve current checkout URL without generating new one
export async function GET(request: NextRequest): Promise<NextResponse<CheckoutResponse>> {
  try {
    const { searchParams } = new URL(request.url);
    const sessionId = searchParams.get('sessionId');

    if (!sessionId) {
      return NextResponse.json(
        {
          success: false,
          error: 'sessionId parameter is required'
        },
        { status: 400 }
      );
    }

    // CRITICAL SECURITY: Retrieve secret cart ID server-side ONLY
    const secretCartId = getSecretCartId(sessionId);

    if (!secretCartId) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid cart session'
        },
        { status: 404 }
      );
    }

    // Retrieve current cart state
    const cartResult = await serverGetCart(secretCartId);

    if (!cartResult.cart) {
      return NextResponse.json(
        {
          success: false,
          error: 'Cart not found'
        },
        { status: 404 }
      );
    }

    const cart = cartResult.cart;

    const response: CheckoutResponse = {
      success: true,
      checkoutUrl: cart.checkoutUrl,
      cart: {
        totalQuantity: cart.totalQuantity || 0,
        cost: {
          totalAmount: cart.cost.totalAmount,
          subtotalAmount: cart.cost.subtotalAmount,
          ...(cart.cost.totalTaxAmount && { totalTaxAmount: cart.cost.totalTaxAmount })
        }
      }
    };

    return NextResponse.json(response, { status: 200 });

  } catch (error) {
    console.error('Checkout URL retrieval error:', error);

    return NextResponse.json(
      {
        success: false,
        error: 'Failed to retrieve checkout URL'
      },
      { status: 500 }
    );
  }
}